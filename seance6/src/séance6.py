# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19-FfzHdeEcpKstCkugJo80O9OWuwTjYu
"""

# -*- coding: utf-8 -*-

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import scipy
import scipy.stats
import math

#Fonction pour ouvrir les fichiers
def ouvrirUnFichier(nom):
    with open(nom, "r") as fichier:
        contenu = pd.read_csv(fichier)
    return contenu

#Fonction pour convertir les données en données logarithmiques
def conversionLog(liste):
    log = []
    for element in liste:
        log.append(math.log(element))
    return log

#Fonction pour trier par ordre décroissant les listes (îles et populations)
def ordreDecroissant(liste):
    liste.sort(reverse = True)
    return liste

#Fonction pour obtenir le classement des listes spécifiques aux populations
def ordrePopulation(pop, etat):
    ordrepop = []
    for element in range(0, len(pop)):
        if np.isnan(pop[element]) == False:
            ordrepop.append([float(pop[element]), etat[element]])
    ordrepop = ordreDecroissant(ordrepop)
    for element in range(0, len(ordrepop)):
        ordrepop[element] = [element + 1, ordrepop[element][1]]
    return ordrepop

#Fonction pour obtenir l'ordre défini entre deux classements (listes spécifiques aux populations)
def classementPays(ordre1, ordre2):
    classement = []
    if len(ordre1) <= len(ordre2):
        for element1 in range(0, len(ordre2) - 1):
            for element2 in range(0, len(ordre1) - 1):
                if ordre2[element1][1] == ordre1[element2][1]:
                    classement.append([ordre1[element2][0], ordre2[element1][0], ordre1[element2][1]])
    else:
        for element1 in range(0, len(ordre1) - 1):
            for element2 in range(0, len(ordre2) - 1):
                if ordre2[element2][1] == ordre1[element1][1]:
                    classement.append([ordre1[element1][0], ordre2[element2][0], ordre1[element][1]])
    return classement

#Partie sur les îles
#iles = pd.DataFrame(ouvrirUnFichier("./data/island-index.csv"))

#Attention ! Il va falloir utiliser des fonctions natives de Python dans les fonctions locales que je vous propose pour faire l'exercice. Vous devez caster l'objet Pandas en list().






#Partie sur les populations des États du monde
#Source. Depuis 2007, tous les ans jusque 2025, M. Forriez a relevé l'intégralité du nombre d'habitants dans chaque États du monde proposé par un numéro hors-série du monde intitulé États du monde. Vous avez l'évolution de la population et de la densité par année.
#monde = pd.DataFrame(ouvrirUnFichier("./data/Le-Monde-HS-Etats-du-monde-2007-2025.csv"))

#Attention ! Il va falloir utiliser des fonctions natives de Python dans les fonctions locales que je vous propose pour faire l'exercice. Vous devez caster l'objet Pandas en list().

# 2: Ouvrir le fichier
def ouvrirUnFichier(adresse):
    return pd.read_csv(adresse)

# Chargement du fichier
df = ouvrirUnFichier("data/island-index.csv")

# Vérification des colonnes (important !)
print(df.columns)

# 3: Isolement de la colonne et ajout
surfaces = df["Surface (km²)"].astype(float).tolist()

# Ajout des continents
surfaces += [
    float(85545323),
    float(37856841),
    float(7768030),
    float(7605049)
]

# 4: Ordonner la liste en ordre décroissant
def ordreDecroissant(liste):
    liste.sort(reverse=True)
    return liste

surfaces_triees = ordreDecroissant(surfaces)
print(surfaces_triees)

# 5: Visualisation de la loi rang-taille

rangs = range(1, len(surfaces_triees) + 1)
plt.plot(rangs, surfaces_triees)
plt.xlabel("Rang")
plt.ylabel("Surface (km²)")
plt.title("Loi rang–taille")
plt.savefig("loi_rang_taille.png")
plt.show()

# 6: Conversion des axes en logarithme

rangs = list(range(1, len(surfaces_triees) + 1))

# Conversion logarithmique des axes
log_surfaces = conversionLog(surfaces_triees)
log_rangs = conversionLog(rangs)

# Visualisation loi rang–taille en log–log
plt.plot(log_rangs, log_surfaces)
plt.xlabel("log(Rang)")
plt.ylabel("log(Surface)")
plt.title("Loi rang–taille (échelle logarithmique)")
plt.savefig("loi_rang_taille_log.png")
plt.show()

# 7: Test sur les rangs
# Il n'est pas pertinent d'effectuer un test statistique classique sur les rangs.
# Les rangs ne sont pas des variables aléatoires indépendantes mais résultent
# d'un ordonnancement déterministe des données (surfaces).
# Toute information statistique est portée par les valeurs (tailles) et non par
# les rangs eux-mêmes. L'analyse se fait donc par observation de la loi rang–taille
# (souvent en échelle logarithmique) et non par un test statistique sur les rangs.

# 9: Ouverture du fichier Le-Monde-HS-Etats-du-monde-2007-2025

df = ouvrirUnFichier("data/Le-Monde-HS-Etats-du-monde-2007-2025.csv")

# 10: Isolement des colonnes

colonnes = ["État", "Pop 2007", "Pop 2025", "Densité 2007", "Densité 2025"]
df_selection = df[colonnes]

print(df_selection.head())

# 11: Ordre décroissant des listes "Pop 2007", "Pop 2025", "Densité 2007", "Densité 2025"

def ordrePopulation(pop, etat):
    ordrepop = []
    for element in range(0, len(pop)):
        if np.isnan(pop[element]) == False:
            ordrepop.append([float(pop[element]), etat[element]])
    ordrepop = ordreDecroissant(ordrepop)
    for element in range(0, len(ordrepop)):
        ordrepop[element] = [element + 1, ordrepop[element][1]]
    return ordrepop

etat = df_selection["État"].tolist()

ordre_pop_2007  = ordrePopulation(df_selection["Pop 2007"].astype(float).tolist(), etat)
ordre_pop_2025  = ordrePopulation(df_selection["Pop 2025"].astype(float).tolist(), etat)
ordre_dens_2007 = ordrePopulation(df_selection["Densité 2007"].astype(float).tolist(), etat)
ordre_dens_2025 = ordrePopulation(df_selection["Densité 2025"].astype(float).tolist(), etat)

def afficherClassement(titre, classement):
    print(titre)
    for rang, etat in classement:
        print(f"{rang}. {etat}")
    print()

afficherClassement("Population 2007", ordre_pop_2007)
afficherClassement("Population 2025", ordre_pop_2025)
afficherClassement("Densité 2007", ordre_dens_2007)
afficherClassement("Densité 2025", ordre_dens_2025)

# 12: Comparaison des listes sur la population et la densité

def classementPays(ordre1, ordre2):
    classement = []
    if len(ordre1) <= len(ordre2):
        for element1 in range(0, len(ordre2) - 1):
            for element2 in range(0, len(ordre1) - 1):
                if ordre2[element1][1] == ordre1[element2][1]:
                    classement.append([ordre1[element2][0],
                                       ordre2[element1][0],
                                       ordre1[element2][1]])
    else:
        for element1 in range(0, len(ordre1) - 1):
            for element2 in range(0, len(ordre2) - 1):
                if ordre2[element2][1] == ordre1[element1][1]:
                    classement.append([ordre1[element1][0],
                                       ordre2[element2][0],
                                       ordre1[element1][1]])
    return classement

comparaison_pop  = classementPays(ordre_pop_2007, ordre_pop_2025)
comparaison_dens = classementPays(ordre_dens_2007, ordre_dens_2025)

comparaison_pop.sort()
comparaison_dens.sort()

print("Comparaison population (2007 → 2025)")
for ligne in comparaison_pop:
    print(ligne)

print("\nComparaison densité (2007 → 2025)")
for ligne in comparaison_dens:
    print(ligne)

# 13: Isolement des deux colonnes sous la forme de deux listes différentes en
# utilisant une boucle

rang_pop_2007 = []
rang_pop_2025 = []

for element in comparaison_pop:
    rang_pop_2007.append(element[0])
    rang_pop_2025.append(element[1])

rang_dens_2007 = []
rang_dens_2025 = []

for element in comparaison_dens:
    rang_dens_2007.append(element[0])
    rang_dens_2025.append(element[1])

print("Population : comparaison des rangs")
for i in range(len(rang_pop_2007)):
    print(f"État {i+1} → 2007 : {rang_pop_2007[i]} | 2025 : {rang_pop_2025[i]}")

print("\nDensité : comparaison des rangs")
for i in range(len(rang_dens_2007)):
    print(f"État {i+1} → 2007 : {rang_dens_2007[i]} | 2025 : {rang_dens_2025[i]}")

# 14: coefficient de corrélation

from scipy.stats import spearmanr, kendalltau

rho_pop, _  = spearmanr(rang_pop_2007,  rang_pop_2025)
tau_pop, _  = kendalltau(rang_pop_2007, rang_pop_2025)

rho_dens, _ = spearmanr(rang_dens_2007, rang_dens_2025)
tau_dens, _ = kendalltau(rang_dens_2007, rang_dens_2025)

print("Population :")
print("  Spearman =", rho_pop)
print("  Kendall  =", tau_pop)

print("\nDensité :")
print("  Spearman =", rho_dens)
print("  Kendall  =", tau_dens)